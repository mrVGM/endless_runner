<!DOCTYPE thml>
<html>
    <head></head>
    <body>
        <canvas width="320" height="240"></canvas>
        <div id="dt"></div>
        <script src="source/assimpjs.js"></script>
        <script>
            ch = undefined;
            async function loadCharacter() {
                const ajs = await assimpjs();
                const fbxName = "assets/slow_run.FBX";

                const fbx = await fetch(fbxName);
                const buff = await fbx.arrayBuffer();

                const fileList = new ajs.FileList();
                fileList.AddFile(fbxName, new Uint8Array(buff));

                const result = ajs.ConvertFileList(fileList, "assjson");
                if (!result.IsSuccess () || result.FileCount () == 0) {
                        onLoad (result.GetErrorCode ());
					return;
				}

                let resultFile = result.GetFile (0);
                let jsonContent = new TextDecoder ().decode (resultFile.GetContent());

                // parse the result json
                let resultJson = JSON.parse(jsonContent);
                return resultJson;
            }
        </script>
        <script>
            let eps = 0.00000001;
            function* permutations(n) {
                function* leftovers(used) {
                    for (let i = 0; i < n; ++i) {
                        if (!used[i]) {
                            yield i;
                        }
                    }
                }
                const stack = [];
                let tmp = leftovers(Array(n).fill(false));
                stack.push({
                    it: tmp,
                    value: undefined
                });

                while (stack.length > 0) {
                    const last = stack[stack.length - 1];
                    last.value = last.it.next();
                    if (last.value.done) {
                        stack.pop();
                        continue;
                    }

                    if (stack.length < n) {
                        const used = Array(n).fill(false);
                        stack.forEach(x => {
                            const i = x.value.value;
                            used[i] = true;
                        });
                        stack.push({
                            it: leftovers(used),
                            value: undefined
                        });
                        continue;
                    }

                    yield stack.map(x => x.value.value);
                }
            }
            function countInversions(perm) {
                let num = 0;
                for (let i = 0; i < perm.length - 1; ++i) {
                    for (let j = i + 1; j < perm.length; ++j) {
                        if (perm[i] > perm[j]) {
                            ++num;
                        }
                    }
                }
                return num;
            }

            function mat3(vals) {
                const data = new Float32Array(9);
                for (let i = 0; i < 9; ++i) {
                    data[i] = vals[i];
                }
                return {
                    data,
                    print: () => {
                        console.log(`${data[0]}\t${data[1]}\t${data[2]}`);
                        console.log(`${data[3]}\t${data[4]}\t${data[5]}`);
                        console.log(`${data[6]}\t${data[7]}\t${data[8]}`);
                    },
                    dim: 3,
                    get: (r, c) => {
                        const i = 3 * r + c;
                        return data[i];
                    },
                    set: (r, c, v) => {
                        const i = 3 * r + c;
                        data[i] = v;
                    }
                };
            }


            function mat4(vals) {
                const data = new Float32Array(16);
                for (let i = 0; i < 16; ++i) {
                    data[i] = vals[i];
                }
                return {
                    data,
                    print: () => {
                        console.log(`${data[0]}\t${data[1]}\t${data[2]}\t${data[3]}`);
                        console.log(`${data[4]}\t${data[5]}\t${data[6]}\t${data[7]}`);
                        console.log(`${data[8]}\t${data[9]}\t${data[10]}\t${data[11]}`);
                        console.log(`${data[12]}\t${data[13]}\t${data[14]}\t${data[15]}`);
                    },
                    dim: 4,
                    get: (r, c) => {
                        const i = 4 * r + c;
                        return data[i];
                    },
                    set: (r, c, v) => {
                        const i = 4 * r + c;
                        data[i] = v;
                    }
                };
            }

            function inverse(mat) {
                const matD = det(mat);
                const res = mat4(new Array(16).fill(0));
                for (let i = 0; i < mat.dim; ++i) {
                    for (let j = 0; j < mat.dim; ++j) {
                        const tmp = [];
                        for (let k = 0; k < mat.dim; ++k) {
                            for (let l = 0; l < mat.dim; ++l) {
                                if (k === i || l === j) {
                                    continue;
                                }
                                tmp.push(mat.get(k, l));
                            }
                        }
                        const adj = mat3(tmp);
                        let d = det(adj);
                        if ((i + j) % 2 === 1) {
                            d *= -1;
                        }

                        res.set(j, i, d) / matD;
                    }
                }
                return res;
            }

            function transpose(mat) {
                let res = mat4(new Float32Array(16).fill(0));
                for (let i = 0; i < 4; ++i) {
                    for (let j = 0; j < 4; ++j) {
                        let val = mat.get(i, j);
                        res.set(j, i, val);
                    }
                }
                return res;
            }

            function multiply(m1, m2) {
                let res = mat4(new Array(16).fill(0));
                let dim = m1.dim;
                for (let i = 0; i < dim; ++i) {
                    for (let j = 0; j < dim; ++j) {
                        let s = 0;
                        for (let k = 0; k < dim; ++k) {
                            s += m1.get(i, k) * m2.get(k, j);
                        }
                        res.set(i, j, s);
                    }
                }
                return res;
            }

            function det(mat) {
                let d = 0;
                const perms = permutations(mat.dim);
                let it = perms.next();
                while (!it.done) {
                    const p = it.value;
                    const inv = countInversions(p);
                    it = perms.next();

                    let tmp = 1;
                    for (let i = 0; i < p.length; ++i) {
                        tmp *= mat.get(i, p[i]);
                    }

                    d += (inv % 2 === 0 ? 1 : -1) * tmp;
                }
                return d;
            }

            function dot(v1, v2) {
                let res = 0;
                for (let i = 0; i < v1.length; ++i) {
                    res += v1[i] * v2[i];
                }
                return res;
            }
            function cross(v1, v2) {
                return [
                    v1[1] * v2[2] - v1[2] * v2[1],
                    -v1[0] * v2[2] + v1[2] * v2[0],
                    v1[0] * v2[1] - v1[1] * v2[0],
                ];
            }

            function transformVector(m, v) {
                let res = new Array(4).fill(0);
                for (let i = 0; i < 4; ++i) {
                    for (let j = 0; j < 4; ++j) {
                        res[i] += m.get(i, j) * v[j];
                    }
                }
                return res;
            }

            function qToMat(q) {
                let x = [1,0,0];
                let y = [0,1,0];
                let z = [0,0,1];

                let xR = qRot(q, x);
                let yR = qRot(q, y);
                let zR = qRot(q, z);

                return mat4([
                    xR[0], yR[0], zR[0], 0,
                    xR[1], yR[1], zR[1], 0,
                    xR[2], yR[2], zR[2], 0,
                       0,    0,    0, 1,
                ]);
            }
            
            let debugTestTrMat = mat4([0.20329336822032928,-0.9453483819961548,0.2549189031124115,19.527799606323242,-0.7366372346878052,0.023839956149458885,0.6758641004562378,77.35446166992188,-0.6450058221817017,-0.3251822888851166,-0.6915337443351746,23.625146865844727,0,0,0,1]);
            function mToQt(m) {
                let origin = [0, 0, 0, 1];
                let x = [1, 0, 0, 1];
                let y = [0, 1, 0, 1];
                let z = [0, 0, 1, 1];

                let oTr = transformVector(m, origin);
                let xTr = transformVector(m, x);
                let yTr = transformVector(m, y);
                let zTr = transformVector(m, z);

                [oTr, xTr, yTr, zTr].forEach(x => {
                    x.pop();
                });

                [xTr, yTr, zTr].forEach(x => {
                    for (let i = 0; i < x.length; ++i) {
                        x[i] -= oTr[i];
                    }
                });

                let offset = oTr;

                let scale = [
                    Math.sqrt(dot(xTr, xTr)),
                    Math.sqrt(dot(yTr, yTr)),
                    Math.sqrt(dot(zTr, zTr)),
                ];

                let orientation = dot(cross(xTr, yTr), zTr);
                if (orientation < 0) {
                    scale[0] *= -1;
                }

                xTr = xTr.map(c => c / scale[0]);
                yTr = yTr.map(c => c / scale[1]);
                zTr = zTr.map(c => c / scale[2]);

                function realQ()
                {
                    let testMat = mat3([
                        xTr[0] - 1,     yTr[0],     zTr[0],
                            xTr[1], yTr[1] - 1,     zTr[1],
                            xTr[2],     yTr[2], zTr[2] - 1,
                    ]);

                    let adjMat = mat3([
                        0, 0, 0, 
                        0, 0, 0, 
                        0, 0, 0, 
                    ]);
                    for (let i = 0; i < 3; ++i) {
                        for (let j = 0; j < 3; ++j) {
                            let it = permutations(3);
                            let d = 0;
                            while (true) {
                                let cur = it.next();
                                if (cur.done) {
                                    break;
                                }

                                let perm = cur.value;
                                let parity = countInversions(perm) % 2 === 0 ? 1 : -1;


                                let curProd = 1;
                                for (let k = 0; k < 3; ++k) {
                                    let getCoef = () => {
                                        if (k === i) {
                                            return perm[k] === j ? 1 : 0;
                                        }
                                        return testMat.get(k, perm[k]);
                                    };
                                    curProd *= getCoef();
                                }
                                d += parity * curProd;
                            }

                            adjMat.set(i, j, d);
                        }
                    }

                    let score = (coord) => {
                        let i = coord[0];
                        let j = coord[1];
                        return Math.abs(adjMat.get(i, j));
                    }

                    let best = [0, 0];
                    for (let i = 0; i < 3; ++i) {
                        for (let j = 0; j < 3; ++j) {
                            let cur = [i, j];
                            if (score(cur) > score(best)) {
                                best = cur;
                            }
                        }
                    }

                    if (score(best) < eps) {
                        return [1, 0, 0, 0];
                    }

                    {
                        let i = best[0];
                        let j = best[1];
                        
                        for (let k = 0; k < 3; ++k) {
                            testMat.set(
                                i,
                                k,
                                k === j ? 1 : 0
                            );
                        }
                    }

                    let embedTo4 = m => {
                        let res = mat4([
                            1, 0, 0, 0, 
                            0, 1, 0, 0, 
                            0, 0, 1, 0, 
                            0, 0, 0, 1, 
                        ]);

                        for (let i = 0; i < 3; ++i) {
                            for (let j = 0; j < 3; ++j) {
                                res.set(i, j, m.get(i, j));
                            }
                        }

                        return res;
                    };

                    let extranctFrom4 = m => {
                        let res = mat3([
                            1, 0, 0, 
                            0, 1, 0, 
                            0, 0, 1, 
                        ]);

                        for (let i = 0; i < 3; ++i) {
                            for (let j = 0; j < 3; ++j) {
                                res.set(i, j, m.get(i, j));
                            }
                        }

                        return res;
                    };

                    {
                        let best4 = embedTo4(testMat);
                        best4 = inverse(best4);
                        testMat = best4;
                    }

                    let rhs = [0,0,0,1];
                    rhs[best[1]] = 1;

                    let axis = transformVector(testMat, rhs);
                    axis.pop();
                    let l = Math.sqrt(dot(axis, axis));
                    axis = axis.map(x => x / l);

                    let ref;

                    {
                        let pairs = [
                            {
                                v1: x.filter((a, i) => i < 3),
                                v2: xTr
                            },
                            {
                                v1: y.filter((a, i) => i < 3),
                                v2: yTr
                            },
                            {
                                v1: z.filter((a, i) => i < 3),
                                v2: zTr
                            },
                        ];

                        let scorePair = (p) => {
                            return Math.abs(dot(axis, p.v1));
                        };
                        let bestRef = pairs[0];
                        pairs.forEach(p => {
                            if (score(p) < score(bestRef)) {
                                bestRef = p;
                            }
                        });

                        ref = cross(axis, bestRef.v1);
                        let refMagnitude = Math.sqrt(dot(ref, ref));
                        ref = ref.map(x => x / refMagnitude);
                    }

                    let oTr = transformVector(m, origin);
                    let refTr = transformVector(m, [ref[0], ref[1], ref[2], 1]);

                    refTr = refTr.map((x, i) => x = x - oTr[i]);
                    refTr.pop();

                    let angle = Math.acos(dot(ref, refTr)) / 2;

                    let q1 = [
                        Math.cos(angle),
                        Math.sin(angle) * axis[0],
                        Math.sin(angle) * axis[1],
                        Math.sin(angle) * axis[2],
                    ];

                    let qs = [q1, qConj(q1)].map(q => {
                        let v = qRot(q, ref);
                        let score = dot(v, refTr);
                        return {
                            q,
                            score
                        };
                    });

                    return qs[0].score > qs[1].score ? qs[0].q : qs[1].q;
                }

                let pairs = [
                    {
                        v1: x.filter((a, i) => i < 3),
                        v2: xTr
                    },
                    {
                        v1: y.filter((a, i) => i < 3),
                        v2: yTr
                    },
                    {
                        v1: z.filter((a, i) => i < 3),
                        v2: zTr
                    },
                ];

                let rotation = realQ();


                return {
                    offset,
                    rotation,
                    scale,
                }
            }

            function qtToM(tr) {
                let offset = tr.offset;
                let scale = tr.scale;
                let rot = tr.rotation;

                let offsetM = mat4([
                    1, 0, 0, offset[0], 
                    0, 1, 0, offset[1], 
                    0, 0, 1, offset[2], 
                    0, 0, 0,         1, 
                ]);

                let scaleM = mat4([
                    scale[0],        0,        0, 0, 
                           0, scale[1],        0, 0, 
                           0,        0, scale[2], 0, 
                           0,        0,        0, 1, 
                ]);

                let xTr = qRot(rot, [1,0,0]);
                let yTr = qRot(rot, [0,1,0]);
                let zTr = qRot(rot, [0,0,1]);

                let rotM = mat4([
                    xTr[0], yTr[0], zTr[0], 0,
                    xTr[1], yTr[1], zTr[1], 0,
                    xTr[2], yTr[2], zTr[2], 0,
                         0,      0,      0, 1,
                ]);

                return multiply(offsetM, multiply(rotM, scaleM));
            }

            function lerp(m1, m2, alpha) {
                let tr1 = mToQt(m1);
                let tr2 = mToQt(m2);

                let offset = [0,0,0];
                let scale = [0,0,0];
                for (let i = 0; i < 3; ++i) {
                    offset[i] =
                        (1 - alpha) * tr1.offset[i]
                        + alpha * tr2.offset[i]; 
                    scale[i] =
                        (1 - alpha) * tr1.scale[i]
                        + alpha * tr2.scale[i]; 
                }

                let x = qMult(tr2.rotation, qConj(tr1.rotation));
                let x1 = x[0];
                x1 = Math.max(-1, x1);
                x1 = Math.min(1, x1);

                function getRot() {
                    let angle = Math.acos(x1);
                    if (angle < eps) {
                        return [1, 0, 0, 0];
                    }

                    let axis = x.filter((_, i) => i > 0);
                    {
                        let l = dot(axis, axis);
                        l = Math.sqrt(l);
                        axis = axis.map(x => x / l);
                    }
                    let v = Math.sin(angle);
                    {
                        let inv = axis.map((c, i) => {
                            return v * c * x[i + 1]; 
                        })
                        .filter(x => x < 0)
                        .length > 0;

                        if (inv) {
                            axis = axis.map(c => -1 * c);
                        }
                    }

                    if (angle > Math.PI / 2) {
                        angle = angle - Math.PI;
                    }

                    angle *= alpha;
                    let rot = [
                        Math.cos(angle),
                        Math.sin(angle) * axis[0],
                        Math.sin(angle) * axis[1],
                        Math.sin(angle) * axis[2],
                    ];
                    return qMult(rot, tr1.rotation);
                }

                let rot = getRot();

                let mSc = mat4([
                    scale[0],        0,        0, 0,
                           0, scale[1],        0, 0,
                           0,        0, scale[2], 0,
                           0,        0,        0, 1, 
                ]);

                let mTr = mat4([
                    1, 0, 0, offset[0], 
                    0, 1, 0, offset[1], 
                    0, 0, 1, offset[2], 
                    0, 0, 0, 1, 
                ]);

                let xTr = qRot(rot, [1,0,0]);
                let yTr = qRot(rot, [0,1,0]);
                let zTr = qRot(rot, [0,0,1]);

                let mRot = mat4([
                    xTr[0],  yTr[0],  zTr[0],  0,
                    xTr[1],  yTr[1],  zTr[1],  0,
                    xTr[2],  yTr[2],  zTr[2],  0,
                         0,       0,       0,  1,
                ]);

                return multiply(mTr, multiply(mRot, mSc));
            }

            let camera = {
                pos: [0, 0, -400],
                fwd: [0, 0, 1],
                near: 0.1,
                far: 1000,
                fov: 30,
                a: 800 / 600,
                transform: mat4(new Array(16).fill(0)),
                projection: mat4(new Array(16).fill(0)),
                mvp: mat4(new Array(16).fill(0)),

                update: () => {
                    function normalize(v) {
                        let magnitude = 0;
                        for (let i = 0; i < v.length; ++i) {
                            magnitude += v[i] * v[i];
                        }
                        magnitude = Math.sqrt(magnitude);
                        for (let i = 0; i < v.length; ++i) {
                            v[i] /= magnitude;
                        }
                    }

                    normalize(camera.fwd);
                    let up = [0, 1, 0];
                    let right = cross(up, camera.fwd);
                    normalize(right);
                    up = cross(camera.fwd, right);
                    normalize(up);

                    camera.transform = mat4([
                        right[0], up[0], camera.fwd[0], camera.pos[0],
                        right[1], up[1], camera.fwd[1], camera.pos[1],
                        right[2], up[2], camera.fwd[2], camera.pos[2],
                               0,     0,             0,             1
                    ]);

                    const h = Math.tan(Math.PI * camera.fov / 180);
                    const w = camera.a * h;
                    camera.projection = mat4([
                        1 / w, 0, 0, 0,
                        0, 1 / h, 0, 0,

                        0, 0,
                        camera.far / (camera.far - camera.near),
                        -camera.far * camera.near / (camera.far - camera.near),


                        0, 0, 1, 0,
                    ]);

                    const inv = inverse(camera.transform);
                    camera.mvp = multiply(
                        camera.projection,
                        inv
                    );
                },

                debugProject: (p) => {
                    const res = new Array(4).fill(0);
                    for (let i = 0; i < 4; ++i) {
                        for (let j = 0; j < 4; ++j) {
                            res[i] += camera.mvp.get(i, j) * p[j];
                        }
                    }

                    for (let i = 0; i < 4; ++i) {
                        res[i] /= res[3];
                    }

                    return res;
                },
                debugChangeCoord: (p) => {
                    const inv = inverse(camera.transform);
                    const res = new Array(4).fill(0);
                    for (let i = 0; i < 4; ++i) {
                        for (let j = 0; j < 4; ++j) {
                            res[i] += inv.get(i, j) * p[j];
                        }
                    }

                    for (let i = 0; i < 4; ++i) {
                        res[i] /= res[3];
                    }

                    return res;
                },
            };

            function qMult(q1, q2) {
                return [
                    q1[0] * q2[0] - q1[1] * q2[1] - q1[2] * q2[2] - q1[3] * q2[3],
                    q1[0] * q2[1] + q1[1] * q2[0] + q1[2] * q2[3] - q1[3] * q2[2],
                    q1[0] * q2[2] - q1[1] * q2[3] + q1[2] * q2[0] + q1[3] * q2[1],
                    q1[0] * q2[3] + q1[1] * q2[2] - q1[2] * q2[1] + q1[3] * q2[0],
                ];
            }

            function qConj(q) {
                return [
                    q[0], -q[1], -q[2], -q[3]
                ];
            }

            function qRot(q, v) {
                const qV = [0, v[0], v[1], v[2]];
                let tmp = qMult(q, qMult(qV, qConj(q)));
                return [tmp[1], tmp[2], tmp[3]];
            }

            const canvas = document.querySelector("canvas");
            console.log(canvas);

            const maxBones = 100;
            async function initWebGPU() {
                const characterFBX = await loadCharacter();
                console.log(characterFBX);

                const character = {
                    meshes: [],
                    animations: characterFBX.animations,
                    sample: (animation, frame) => {
                        const locals = {};
                        animation.channels.forEach(channel => {
                            let pos = channel.positionkeys[frame][1];
                            let rot = channel.rotationkeys[frame][1];
                            let scale = channel.scalingkeys[frame][1];

                            let mSc = mat4([
                                scale[0],        0,        0, 0, 
                                       0, scale[1],        0, 0, 
                                       0,        0, scale[2], 0, 
                                       0,        0,        0, 1, 
                            ]);

                            let mR = qToMat(rot);
                            let mTr = mat4([
                                1, 0, 0, pos[0], 
                                0, 1, 0, pos[1], 
                                0, 0, 1, pos[2], 
                                0, 0, 0, 1, 
                            ]);

                            locals[channel.name] = multiply(mTr, multiply(mR, mSc));
                        });

                        let glob = {};
                        {
                            function calcGlobTr(bone) {
                                if (glob[bone]) {
                                    return;
                                }

                                let skBone = character.skeleton[bone];
                                let localTr = locals[bone] ? locals[bone] : skBone.defaultTr;

                                if (!skBone.parent) {
                                    glob[bone] = localTr;
                                    return;
                                }
                                
                                calcGlobTr(skBone.parent);
                                let parentTr = glob[skBone.parent];
                                glob[bone] = multiply(parentTr, localTr);
                            }

                            for (let bone in locals) {
                                if (!glob[bone]) {
                                    calcGlobTr(bone);
                                }
                            }
                        }
                        return glob;
                    },
                };

                ch = character;
                let boneSet = {};
                {
                    characterFBX.meshes.forEach(mesh => {
                        const meshVerts = [];
                        {
                            function* v() {
                                for (let i = 0; i < mesh.vertices.length; ++i) {
                                    yield mesh.vertices[i];
                                }
                            }
                            function* n() {
                                for (let i = 0; i < mesh.vertices.length; ++i) {
                                    yield mesh.normals[i];
                                }
                            }
                            function* t() {
                                let texCoord = mesh.texturecoords[0];
                                for (let i = 0; i < texCoord.length; ++i) {
                                    yield texCoord[i];
                                }
                            }

                            function* vIt() {
                                let vi = v();
                                let ni = n();
                                let ti = t();

                                while (true) {
                                    for (let i = 0; i < 3; ++i) {
                                        let v = vi.next();
                                        if (v.done) {
                                            return;
                                        }

                                        yield v.value;
                                    }
                                    for (let i = 0; i < 3; ++i) {
                                        let n = ni.next();
                                        yield n.value;
                                    }
                                    for (let i = 0; i < 2; ++i) {
                                        let t = ti.next();
                                        yield t.value;
                                    }
                                }
                            }

                            let it = vIt();
                            while (true) {
                                let cur = it.next();
                                if (cur.done) {
                                    break;
                                }
                                meshVerts.push(cur.value);
                            }
                        }

                        let meshIndices = [];
                        mesh.faces.forEach(x => {
                            meshIndices = meshIndices.concat(x);
                        });

                        const weightArr =
                            new Array(mesh.vertices.length / 3);

                        let bones = mesh.bones;
                        if (!bones) {
                            bones = [];
                        }
                        for (let i = 0; i < bones.length; ++i) {
                            const cur = bones[i];
                            cur.weights.forEach(w => {
                                if (!weightArr[w[0]]) {
                                    weightArr[w[0]] = {weights: []};
                                }
                                weightArr[w[0]].weights.push({
                                    bone: i,
                                    weight: w[1]
                                });
                            });
                        }

                        const meshObj = {
                            verts: new Float32Array(meshVerts),
                            indices: new Uint32Array(meshIndices),
                            boneMap: {},
                            bones: bones.map(x => {
                                return {
                                    name: x.name,
                                    offset: mat4(x.offsetmatrix)
                                }
                            }),
                            pose: bones.map(_ => {
                                return mat4([
                                    1, 0, 0, 0,  
                                    0, 1, 0, 0,  
                                    0, 0, 1, 0,  
                                    0, 0, 0, 1,  
                                ]);
                            }),
                            weights: weightArr,
                        };

                        bones.forEach((x, i) => {
                            meshObj.boneMap[x.name] = i;
                            boneSet[x.name] = true;
                        });
                        character.meshes.push(meshObj);
                    });

                    character.skeleton = {};
                    {
                        function traverse(node, parentName, parentTr) {
                            let curTr = multiply(parentTr, mat4(node.transformation));
                            if (boneSet[node.name]) {
                                character.skeleton[node.name] = {
                                    parent: parentName,
                                    defaultTr: curTr,
                                }
                                parentName = node.name;
                            }

                            if (!node.children) {
                                return
                            }

                            for (let i = 0; i < node.children.length; ++i) {
                                traverse(node.children[i], parentName, curTr);
                            }
                        }
                        let unit = mat4([
                            1, 0, 0, 0, 
                            0, 1, 0, 0, 
                            0, 0, 1, 0, 
                            0, 0, 0, 1, 
                        ]);
                        traverse(characterFBX.rootnode, undefined, unit);
                    }

                    character.applyAnim = (anim, frame1, frame2, alpha) => {
                        function getMatrices() {
                            if (alpha < eps) {
                                return character.sample(anim, frame1);
                            }
                            if (alpha > 1 - eps) {
                                return character.sample(anim, frame2);
                            }

                            let mats1 = character.sample(anim, frame1);
                            let mats2 = character.sample(anim, frame2);

                            let mats3 = {};

                            for (let bone in mats1) {
                                let m1 = mats1[bone];
                                let m2 = mats2[bone];

                                mats3[bone] = lerp(m1, m2, alpha);
                            }

                            return mats3;
                        }
                        let res = getMatrices();

                        character.meshes.forEach(mesh => {
                            mesh.bones.forEach((bone, i) => {
                                const boneTr = bone.offset;
                                const tr = multiply(res[bone.name], boneTr);
                                mesh.pose[i] = tr;
                            });
                        });
                    };

                    function updateInitialTransforms() {
                        function helper(node, parentTr) {
                            let matrix = multiply(parentTr, mat4(node.transformation));
                            if (node.meshes) {
                                node.meshes.forEach(x => {
                                    character.meshes[x].initialTransform = matrix;
                                });
                            }

                            if (node.children) {
                                for (let i = 0; i < node.children.length; ++i) {
                                    helper(node.children[i], matrix);
                                }
                            }
                        }
                        let unit = mat4([
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, 0, 0, 1,
                        ]);

                        let curNode = characterFBX.rootnode;
                        helper(curNode, unit);
                    }
                    character.updateInitialTransforms = updateInitialTransforms;

                    updateInitialTransforms();
                }
                console.log(character);

                const adapter = await navigator.gpu?.requestAdapter({
                    featureLevel: 'compatibility',
                });
                const device = await adapter.requestDevice();
                const context = canvas.getContext('webgpu');

                const devicePixelRatio = window.devicePixelRatio;
                canvas.width = canvas.clientWidth * devicePixelRatio;
                canvas.height = canvas.clientHeight * devicePixelRatio;
                const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

                context.configure({
                    device,
                    format: presentationFormat,
                });

                console.log(context);

                let vertexShader = fetch("assets/shaders/vertex.wgsl");
                let fragmentShader = fetch("assets/shaders/fragment.wgsl")
                await Promise.all([vertexShader, fragmentShader]);
                vertexShader = await (await vertexShader).text();
                fragmentShader = await (await fragmentShader).text();

                // console.log(vertexShader, fragmentShader);

                let cameraBufferDST = device.createBuffer({
                    label: "camera buffer dst",
                    size: 16 * 4,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });

                let cameraBufferSRC = device.createBuffer({
                    label: "camera buffer src",
                    size: 16 * 4,
                    usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
                });

                const dummyBuffer = device.createBuffer({
                    label: "dummy buffer",
                    size: 16 * 4 * maxBones,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
                {
                    let tmp = new Uint8Array(512);
                    tmp[0] = 0;
                    tmp[256] = 1;
                    device.queue.writeBuffer(dummyBuffer, 0, tmp);
                    await device.queue.onSubmittedWorkDone();
                }

                const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        {
                            binding: 0, // camera uniforms
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "uniform"
                            },
                        },
                        {
                            binding: 1, // transform uniforms
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "uniform"
                            },
                        },
                        {
                            binding: 2, // is skeletal
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "uniform"
                            },
                        },
                        {
                            binding: 3, // pose uniforms
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "uniform"
                            },
                        },
                    ]
                });

                const pipelineLayout = device.createPipelineLayout({
                    bindGroupLayouts: [
                        bindGroupLayout, // @group(0)
                    ]
                });

                const tickUpdates = [];

                character.renderElements = [];
                {
                    let meshIndex = 0;
                    character.meshes.forEach(mesh => {
                        const verts = mesh.verts;
                        const indices = mesh.indices;

                        const vertexBuffer = device.createBuffer({
                            label: `vertex buffer ${meshIndex}`,
                            size: 4 * verts.length,
                            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                        });
                        device.queue.writeBuffer(vertexBuffer, 0, verts);

                        const indexBuffer = device.createBuffer({
                            label: `index buffer ${meshIndex}`,
                            size: 4 * indices.length,
                            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
                        });
                        device.queue.writeBuffer(indexBuffer, 0, indices);

                        let transformBufferDST = device.createBuffer({
                            label: `trasform buffer dst ${meshIndex}`,
                            size: 16 * 4,
                            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                        });

                        let transformBufferSRC = device.createBuffer({
                            label: `trasform buffer src ${meshIndex}`,
                            size: 16 * 4,
                            usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
                        });

                        tickUpdates.push(async () => {
                            await transformBufferSRC.mapAsync(GPUMapMode.WRITE);
                            let mapped = transformBufferSRC.getMappedRange();

                            let bufView = new Float32Array(mapped);
                            let transp = transpose(mesh.initialTransform);
                            bufView.set(transp.data);
                            transformBufferSRC.unmap();

                            const commandEncoder = device.createCommandEncoder();
                            commandEncoder.copyBufferToBuffer(
                                transformBufferSRC,
                                0,
                                transformBufferDST,
                                0,
                                16 * 4
                            );
                            const finishedEncoder = commandEncoder.finish();
                            device.queue.submit([finishedEncoder]);
                        });

                        let weightsBuff = dummyBuffer;
                        let poseBuff = dummyBuffer;

                        if (mesh.bones.length > 0) {
                            {
                                const wSize = 64 * mesh.weights.length;
                                weightsBuff = device.createBuffer({
                                    label: `weights buffer ${meshIndex}`,
                                    size: wSize,
                                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                                });
                                const tmp = new ArrayBuffer(wSize);
                                const intView = new Int32Array(tmp);
                                const floatView = new Float32Array(tmp);
                                let index = 0;
                                for (let i = 0; i < mesh.weights.length; ++i) {
                                    let cur = mesh.weights[i].weights;

                                    for (let j = 0; j < 8; ++j) {
                                        intView[index + j] = -1;
                                        floatView[index + 8 + j] = 1;
                                    }

                                    for (let j = 0; j < cur.length; ++j) {
                                        intView[index + j] = cur[j].bone;
                                        floatView[index + 8 + j] = cur[j].weight;
                                    }
                                    index += 16;
                                }
                                device.queue.writeBuffer(weightsBuff, 0, tmp);
                            }
                            {
                                let poseBufferDST = device.createBuffer({
                                    label: `pose buffer dst ${meshIndex}`,
                                    size: 16 * 4 * maxBones,
                                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                                });

                                poseBuff = poseBufferDST;

                                let poseBufferSRC = device.createBuffer({
                                    label: `pose buffer src ${meshIndex}`,
                                    size: 16 * 4 * maxBones,
                                    usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
                                });

                                tickUpdates.push(async () => {
                                    await poseBufferSRC.mapAsync(GPUMapMode.WRITE);
                                    let mapped = poseBufferSRC.getMappedRange();

                                    let bufView = new Float32Array(mapped);
                                    for (let i = 0; i < mesh.pose.length; ++i) {
                                        let cur = mesh.pose[i];
                                        let transp =
                                            transpose(cur);
                                        for (let j = 0; j < 16; ++j) {
                                            bufView[i * 16 + j] = transp.data[j];
                                        }
                                    }

                                    poseBufferSRC.unmap();
                                    const commandEncoder = device.createCommandEncoder();
                                    commandEncoder.copyBufferToBuffer(
                                        poseBufferSRC,
                                        0,
                                        poseBufferDST,
                                        0,
                                        16 * 4 * maxBones
                                    );
                                    const finishedEncoder = commandEncoder.finish();
                                    device.queue.submit([finishedEncoder]);
                                });
                            }
                        }

                        const bindGroup = device.createBindGroup({
                            label: `bind group ${meshIndex}`,
                            layout: bindGroupLayout,
                            entries: [
                                {
                                    binding: 0,
                                    resource: { buffer: cameraBufferDST },
                                },
                                {
                                    binding: 1,
                                    resource: { buffer: transformBufferDST },
                                },
                                {
                                    binding: 2,
                                    resource: { 
                                        buffer: dummyBuffer,
                                        offset: (mesh.bones.length > 0) ? 256 : 0,
                                    },
                                },
                                {
                                    binding: 3,
                                    resource: { buffer: poseBuff },
                                },
                            ],
                        });
                        character.renderElements.push({
                            vertexBuffer,
                            weightsBuff,
                            indexBuffer,
                            indices: indices.length,
                            bindGroup
                        });

                        ++meshIndex;
                    });

                    await device.queue.onSubmittedWorkDone();
                }

                console.log("vertex/index buffer ready");

                const depthTexture = device.createTexture({
                    label: "depth stencil",
                    size: [canvas.width, canvas.height],
                    format: "depth24plus",
                    usage: GPUTextureUsage.RENDER_ATTACHMENT,
                });

                const pipeline = device.createRenderPipeline({
                    label: "simple pipeline",
                    layout: pipelineLayout,
                    vertex: {
                        module: device.createShaderModule({
                            code: vertexShader,
                        }),
                        buffers: [
                            {
                                arrayStride: 3 * 4 + 3 * 4 + 2 * 4,
                                attributes: [
                                    {
                                        shaderLocation: 0,
                                        offset: 0,
                                        format: "float32x3"
                                    },
                                    {
                                        shaderLocation: 1,
                                        offset: 12,
                                        format: "float32x3"
                                    },
                                    {
                                        shaderLocation: 2,
                                        offset: 24,
                                        format: "float32x2"
                                    },
                                ]
                            },
                            {
                                arrayStride: 2 * 8 * 4,
                                attributes: [
                                    {
                                        shaderLocation: 10,
                                        offset: 0,
                                        format: "uint32x4"
                                    },
                                    {
                                        shaderLocation: 11,
                                        offset: 16,
                                        format: "uint32x4"
                                    },
                                    {
                                        shaderLocation: 12,
                                        offset: 32,
                                        format: "float32x4"
                                    },
                                    {
                                        shaderLocation: 13,
                                        offset: 48,
                                        format: "float32x4"
                                    },
                                ]
                            }
                        ]
                    },
                    fragment: {
                        module: device.createShaderModule({
                            code: fragmentShader,
                        }),
                        targets: [
                            {
                                format: presentationFormat,
                            },
                        ],
                    },
                    primitive: {
                        topology: 'triangle-list',
                    },
                    depthStencil: {
                        depthWriteEnabled: true,
                        depthCompare: "less",
                        format: "depth24plus",
                    },
                });

                async function updateCam() {
                    camera.update();
                    await cameraBufferSRC.mapAsync(GPUMapMode.WRITE);
                    let mapped = cameraBufferSRC.getMappedRange();

                    let camBufView = new Float32Array(mapped);
                    let transp = transpose(camera.mvp);
                    camBufView.set(transp.data);

                    // for (let i = 0; i < 16; ++i) {
                    //     camBufView.setFloat32(camera.mvp.data[i]);
                    // }
                    cameraBufferSRC.unmap();

                    const commandEncoder = device.createCommandEncoder();
                    commandEncoder.copyBufferToBuffer(
                        cameraBufferSRC,
                        0,
                        cameraBufferDST,
                        0,
                        16 * 4
                    );
                    const finishedEncoder = commandEncoder.finish();
                    device.queue.submit([finishedEncoder]);
                }
                tickUpdates.push(updateCam);

                let animProg = 0;
                function sampleAnim(dt) {
                    animProg += dt;
                    let elapsedSecs = animProg / 1000;
                    let anim = character.animations[0];
                    let ticks = elapsedSecs * anim.tickspersecond;
                    let left = Math.floor(ticks) % anim.duration;
                    let right = Math.ceil(ticks) % anim.duration;
                    let alpha = ticks - Math.floor(ticks);
                    character.applyAnim(anim, left, right, alpha);
                }

                let fpsMon = document.querySelector("div#dt");
                let diff = 0;
                while(true) {
                    let startFrame = Date.now();
                    sampleAnim(diff);
                    character.updateInitialTransforms();
                    await Promise.all(tickUpdates.map(x => x()));
                    await device.queue.onSubmittedWorkDone();

                    const textureView = context.getCurrentTexture().createView();
                    const renderPassDescriptor = {
                        colorAttachments: [
                            {
                                view: textureView,
                                clearValue: [0, 0, 0, 0], // Clear to transparent
                                loadOp: 'clear',
                                storeOp: 'store',
                            },
                        ],
                        depthStencilAttachment: {
                            view: depthTexture.createView(),
                            depthClearValue: 1.0,
                            depthLoadOp: "clear",
                            depthStoreOp: "store",
                        },
                    };

                    const commandEncoder = device.createCommandEncoder();
                    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                    character.renderElements.forEach(re => {

                        passEncoder.setVertexBuffer(0, re.vertexBuffer);
                        passEncoder.setVertexBuffer(1, re.weightsBuff);
                        passEncoder.setIndexBuffer(re.indexBuffer, "uint32");

                        passEncoder.setPipeline(pipeline);
                        passEncoder.setBindGroup(0, re.bindGroup);

                        passEncoder.drawIndexed(re.indices);
                    });
                    passEncoder.end();
                    const finishedEncoder = commandEncoder.finish();

                    device.queue.submit([finishedEncoder]);
                    let pr = device.queue.onSubmittedWorkDone();
                    await pr;
                    let now = Date.now();
                    diff = now - startFrame;
                    fpsMon.innerHTML = diff;
                }
            }

            initWebGPU();
        </script>
        <script>
            // init();
        </script>
    </body>
</html>